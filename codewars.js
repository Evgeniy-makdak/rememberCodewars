// ************************************************************** 1
// Задав строку, выделите буквы, занимающие четные и нечетные индексы, отдельно и верните, как показано ниже. Индекс 0 будет считаться четным.
// Например, capitalize("abcdef") = ['AbCdEf', 'aBcDeF']. 
// На вход будет подана строка в нижнем регистре без пробелов. 
// #7kyu

function capitalize(s) {
  const sortArrayFirst = [];
  const sortArraySecond = [];
  for (let i = 0; i <= s.length; i++) {
    if (i % 2 === 0) {
        sortArrayFirst.push(s[i].toUpperCase())
    } else {
        sortArrayFirst.push(s[i]);
    };
  }
  return sortArrayFirst.join('');
};

// console.log(capitalize('asdfg'));

// ************************************************************** 2
// Определите функцию, которая принимает целочисленный аргумент и возвращает 
// логическое значение true или false в зависимости от того, является ли это целое число простым.
// ТРЕБОВАНИЯ:
// Вы можете предположить, что вам будет задано целое число.
// Вы не можете предполагать, что это целое число будет только положительным. Вам могут быть даны и отрицательные числа ( или 0 ).
// Замечание по производительности: Не требуется никаких причудливых оптимизаций, 
// но все же самые тривиальные решения могут выходить из строя. Циклы до n или n/2 будут слишком медленными.
// ПРИМЕР:
// isPrime(1) /* false */
// isPrime(2) /* true */
// isPrime(-1) /* false */

function isPrime(num) {
  if (num < 2) return false;
  for (let i = 2; i <= Math.sqrt(num); i++) {
    if (num % i === 0) return false;

  } return true;
}

console.log(isPrime(73));

// ************************************************************** 3
